import utils from './utils';
import { REMOVE, INSERT, PROPS, TEXT, REPLACE, ORDER } from './constants';
import createElement from './create_element';

/**
 * patch 根据 diff 的结果对差异进行更新
 * @param {*} root HTML rootNode generated by vnode
 * @param {*} patches
 */
function patch(root, patches) {
  let index = 0;

  patchNode(root, patches, index);
}

function patchNode(node, patches, index) {
  let currentPatch = patches[index] || [];

  currentPatch.forEach((patch, i) => {
    switch (patch.type) {
      case INSERT:
        // console.log(node, patch, 'insert');
        // console.log(patch.node);
        break;
      case REMOVE:
        console.log(node, patch, 'remove');
        node.parentNode.removeChild(node);
        break;
      case REPLACE:
        // console.log(node, patch.node, 'replace');
        const newNode = createElement(patch.node);
        node.parentNode.replaceChild(newNode, node);
        break;
      case ORDER:
        // console.log(node, patch, 'reorder');
        reorderChildren(node, patch.moves);
        break;
      case PROPS:
        // console.log(node, patch.props, 'props');
        utils.setAttrs(node, patch.props);
        break;
      case TEXT:
        // console.log(node, patch, 'text');
        // console.log(node.parentNode);
        node.parentNode.textContent = patch.content;
        // utils.setAttrs(node, patch.props);
        break;
    }
  });

  node.childNodes.forEach((node, i) => {
    index++;
    // console.log(node);
    patchNode(node, patches, i + index);
  });
}

function reorderChildren(node, moves) {
  // console.log(node.childNodes);
  const nodeList = [].slice.call(node.childNodes);
  // console.log(nodeList);
  moves.forEach(move => {
    let index = move.index;
    // console.log(move.index);
    // console.log(move);
    if (move.type === REMOVE) {
      // console.log(index, nodeList[index], node.childNodes[index]);
      // console.log(nodeList[index]);

      node.removeChild(nodeList[index]);

      // if (nodeList[index] === node.childNodes[index]) {
      //   // console.log(move.index);
      //   // console.log(node, nodeList[index], node.childNodes[index]);
      //   // if (node.childNodes[index]) {
      //   // console.log(node.childNodes[index]);
      //   // node.removeChild(node.childNodes[index]);
      //   // }
      // }

      // nodeList.splice(index, 1);
      // console.log(index, nodeList);
    } else if (move.type === ORDER) {
      let insertNode = utils.isObject(move.item)
        ? createElement(move.item)
        : document.createTextNode(move.item);

      // console.log('insertNode: ');
      // console.log(insertNode);
      // console.log(node.childNodes[move.index]);
      nodeList.splice(index, 0, insertNode);
      node.insertBefore(insertNode, node.childNodes[index] || null);
    }
  });
}

export default patch;
